| задача                                                       | отметка о выполнении | комментарий                                                  |
| ------------------------------------------------------------ | -------------------- | ------------------------------------------------------------ |
| Настройте сервер так, чтобы в журнал сообщений сбрасывалась <br />информация о блокировках, удерживаемых более 200 миллисекунд. <br />Воспроизведите  ситуацию, при которой в журнале появятся такие сообщения. | +                    | ALTER SYSTEM SET log_lock_waits = on;<br />SELECT pg_reload_conf();<br />alter system set deadlock_timeout = '200ms';<br />SELECT pg_reload_conf();<br />SHOW deadlock_timeout;<br />create database locks;<br /><br />create table test (i int);<br />insert into test  values (1), (2), (3);<br />далее с 2х сессий конект к новой базе через \c locks<br />начинаем транзакцию в одной сессии:begin; update test set i =4 where i = 1;<br />делаем апдейт во второй сессии: update test set i = 6 where i = 1;<br />в первой сессии закоммитим (пока идёт переключение, как раз пройдёт больше 200мс): commit;<br />проверим журнал: tail -n 10 /var/log/postgresql/postgresql-14-main.log |
| Смоделируйте ситуацию обновления одной и той же строки тремя командами  <br />UPDATE в разных сеансах. Изучите возникшие блокировки в представлении  <br />pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и  объясните, что значит каждая. | +                    | 1я сессия: begin; SELECT pg_backend_pid(); update test set i =7 where i = 3;<br />2я сессия: SELECT pg_backend_pid(); update test set i =8 where i = 3;<br />3я сессия: SELECT pg_backend_pid(); update test set i =9 where i = 3;<br />возникли следующие блокировки:<br />RowExclusiмeLock - эксклюзивная блокировка на строку, означает что блокируется не вся таблица, а только конкретная стркока. Если в параллельных транзакциях будут модификации других строк, то эта блокировка не должна мешать. Но попытка чтения или обновления этой строки в других транзакциях приведёт к ожиданию.<br />ShareLock - не мешает читать данные с объекта другим транзакциям, но как только в любой другой тразакции попытаются модифицировать данные - будут ожидать завершения транзакции с shareLock<br />ExclusiveLock - запрещает в рамках других сессий читать или модифицировать данные, в результате чего транзакции,пытающиеся это сделать будут ждать завершения транзакции с ExclusiveLock . |
| Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться <br />в ситуации постфактум, изучая журнал сообщений? | +                    | 1я сессия: begin; SELECT pg_backend_pid(); update test set i =9 where i = 8;<br />2я сессия: begin; SELECT pg_backend_pid(); update test set i =10 where i = 5;<br />3я сессия: begin; SELECT pg_backend_pid(); update test set i =11 where i = 4;<br />1я сессия: update test set i =9 where i = 5;<br />2я сессия: update test set i =10 where i = 4;<br />3я сессия: update test set i =11 where i = 8;<br />Посмотрим журнал:tail -n 100 /var/log/postgresql/postgresql-14-main.log<br />Изучая журнал постфактум можно обратить внимание на запись Error: deadlock detected и просмотря журнал выше найти место, где начались блокировки и пройдя ниже от начала восстановить последовательность команд и транзакций, которые привели к взаимоблокировке. |
| Могут ли две транзакции, выполняющие единственную команду UPDATE <br />одной и той же таблицы (без where), заблокировать друг друга? | +                    | Насколько я понимаю, каждая из транзакций совершит по проходу по таблице последовательно, поэтому именно взаимоблокировка, на мой взгляд маловероятна. А обычная будет 100%. |

